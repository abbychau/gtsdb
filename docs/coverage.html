
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>buffer: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">gtsdb/buffer/external.go (94.9%)</option>
				
				<option value="file1">gtsdb/buffer/internal.go (92.3%)</option>
				
				<option value="file2">gtsdb/concurrent/lru.go (95.0%)</option>
				
				<option value="file3">gtsdb/concurrent/map.go (100.0%)</option>
				
				<option value="file4">gtsdb/concurrent/set.go (100.0%)</option>
				
				<option value="file5">gtsdb/fanout/fanout.go (100.0%)</option>
				
				<option value="file6">gtsdb/main.go (90.6%)</option>
				
				<option value="file7">gtsdb/synchronous/ringbuffer.go (93.8%)</option>
				
				<option value="file8">gtsdb/utils/utils.go (87.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package buffer

import (
        "encoding/json"
        "fmt"
        "gtsdb/models"
        "gtsdb/synchronous"
        "gtsdb/utils"
        "math"
        "os"
        "sort"
        "strings"
        "sync"
)

func InitIDSet() <span class="cov8" title="1">{
        // Read all the files in the data directory
        files, err := os.ReadDir(utils.DataDir)
        if err != nil </span><span class="cov0" title="0">{
                utils.InitDataDirectory()
                return
        }</span>
        <span class="cov8" title="1">for _, file := range files </span><span class="cov8" title="1">{
                if strings.HasSuffix(file.Name(), ".aof") </span><span class="cov8" title="1">{
                        id := file.Name()[:len(file.Name())-4]
                        if id != "" </span><span class="cov8" title="1">{
                                allIds.Add(id)
                        }</span>
                }
        }
}

func InitKey(dataPointId string) <span class="cov8" title="1">{
        if dataPointId == "" </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">prepareFileHandles(dataPointId+".aof", dataFileHandles)
        prepareFileHandles(dataPointId+".idx", indexFileHandles)
        allIds.Add(dataPointId)</span>
}
func RenameKey(dataPointId, newId string) <span class="cov8" title="1">{
        if newId == "" || dataPointId == "" </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">utils.Log("Renaming key: %v to %v", dataPointId, newId)
        renameLock.Lock()
        defer renameLock.Unlock()

        dfk := dataPointId + ".aof"
        ifk := dataPointId + ".idx"
        newDfk := newId + ".aof"
        newIfk := newId + ".idx"

        // Close and remove old file handles
        if dfh, ok := dataFileHandles.Load(dfk); ok </span><span class="cov8" title="1">{
                dfh.Close()
                dataFileHandles.Delete(dfk)
        }</span>
        <span class="cov8" title="1">if ifh, ok := indexFileHandles.Load(ifk); ok </span><span class="cov8" title="1">{
                ifh.Close()
                indexFileHandles.Delete(ifk)
        }</span>

        // Remove from allIds before renaming
        <span class="cov8" title="1">allIds.Remove(dataPointId)

        // Rename the files
        err1 := os.Rename(utils.DataDir+"/"+dfk, utils.DataDir+"/"+newDfk)
        err2 := os.Rename(utils.DataDir+"/"+ifk, utils.DataDir+"/"+newIfk)

        if err1 != nil || err2 != nil </span><span class="cov0" title="0">{
                utils.Errorln("Error renaming files:", err1, err2)
                return
        }</span>

        // Create new file handles
        <span class="cov8" title="1">prepareFileHandles(newDfk, dataFileHandles)
        prepareFileHandles(newIfk, indexFileHandles)

        // Add new ID
        allIds.Add(newId)</span>
}

func DeleteKey(dataPointId string) <span class="cov8" title="1">{
        utils.Log("Deleting key: %v", dataPointId)
        renameLock.Lock()
        dfk := dataPointId + ".aof"
        ifk := dataPointId + ".idx"

        //close file handles
        dfh, _ := dataFileHandles.Load(dfk)
        dfh.Close()
        ifh, _ := indexFileHandles.Load(ifk)
        ifh.Close()

        dataFileHandles.Delete(dfk)
        indexFileHandles.Delete(ifk)
        allIds.Remove(dataPointId)

        //delete the file
        err := os.Remove(utils.DataDir + "/" + dfk)
        if err != nil </span><span class="cov0" title="0">{
                utils.Errorln(err)
        }</span>
        <span class="cov8" title="1">err = os.Remove(utils.DataDir + "/" + ifk)
        if err != nil </span><span class="cov8" title="1">{
                utils.Errorln(err)
        }</span>
        <span class="cov8" title="1">renameLock.Unlock()</span>
}

func StoreDataPointBuffer(dataPoint models.DataPoint) <span class="cov8" title="1">{
        allIds.Add(dataPoint.ID)
        if cacheSize == 0 </span><span class="cov8" title="1">{
                storeDataPoints(dataPoint.ID, []models.DataPoint{dataPoint})
                return
        }</span>

        <span class="cov8" title="1">rb, ok := idToRingBufferMap.Load(dataPoint.ID)
        if !ok </span><span class="cov8" title="1">{
                newRb := synchronous.NewRingBuffer[models.DataPoint](cacheSize)
                idToRingBufferMap.Store(dataPoint.ID, newRb)
                rb = newRb
        }</span>
        <span class="cov8" title="1">rb.Push(dataPoint)

        storeDataPoints(dataPoint.ID, []models.DataPoint{dataPoint})

        lastValue[dataPoint.ID] = dataPoint.Value
        lastTimestamp[dataPoint.ID] = dataPoint.Timestamp</span>
}

func PatchDataPoints(dataPoints []models.DataPoint, key string) <span class="cov8" title="1">{
        /*
                1. sort input data points by timestamp
                2. get all data points from key
                3. merge input data points with existing data points
                4. write merged data points to file
                5. rebuild index file
        */

        lock, _ := dataPatchLocks.LoadOrStore(key, &amp;sync.Mutex{}) //ignore the second return value because we don't care if it was loaded
        lock.Lock()
        defer lock.Unlock()

        // sort input data points by timestamp
        sort.Slice(dataPoints, func(i, j int) bool </span><span class="cov8" title="1">{
                return dataPoints[i].Timestamp &lt; dataPoints[j].Timestamp
        }</span>)

        // get all data points from key
        <span class="cov8" title="1">existingDataPoints := readFiledDataPoints(key, 0, math.MaxInt64)

        // merge input data points with existing data points
        newDataCursor := 0
        existingDataCursor := 0

        var mergedDataPoints []models.DataPoint

        for newDataCursor &lt; len(dataPoints) &amp;&amp; existingDataCursor &lt; len(existingDataPoints) </span><span class="cov8" title="1">{
                newDataPoint := dataPoints[newDataCursor]
                existingDataPoint := existingDataPoints[existingDataCursor]

                if newDataPoint.Timestamp &lt; existingDataPoint.Timestamp </span><span class="cov8" title="1">{
                        mergedDataPoints = append(mergedDataPoints, newDataPoint)
                        newDataCursor++
                }</span> else<span class="cov8" title="1"> if newDataPoint.Timestamp &gt; existingDataPoint.Timestamp </span><span class="cov8" title="1">{
                        mergedDataPoints = append(mergedDataPoints, existingDataPoint)
                        existingDataCursor++
                }</span> else<span class="cov8" title="1"> {
                        // Overwrite old data with new data if timestamps are the same
                        mergedDataPoints = append(mergedDataPoints, newDataPoint)
                        newDataCursor++
                        existingDataCursor++
                }</span>
        }

        <span class="cov8" title="1">for newDataCursor &lt; len(dataPoints) </span><span class="cov8" title="1">{
                mergedDataPoints = append(mergedDataPoints, dataPoints[newDataCursor])
                newDataCursor++
        }</span>

        <span class="cov8" title="1">for existingDataCursor &lt; len(existingDataPoints) </span><span class="cov8" title="1">{
                mergedDataPoints = append(mergedDataPoints, existingDataPoints[existingDataCursor])
                existingDataCursor++
        }</span>

        // remove key
        <span class="cov8" title="1">DeleteKey(key)

        // write merged data points to file
        storeDataPoints(key, mergedDataPoints)</span> // this will also rebuild the index file

}

func ReadDataPoints(id string, startTime, endTime int64, downsample int, aggregation string) []models.DataPoint <span class="cov8" title="1">{

        dataPoints := readBufferedDataPoints(id, startTime, endTime)
        if len(dataPoints) == 0 </span><span class="cov8" title="1">{
                dataPoints = readFiledDataPoints(id, startTime, endTime)
        }</span>

        <span class="cov8" title="1">if downsample &gt; 1 </span><span class="cov8" title="1">{
                dataPoints = downsampleDataPoints(dataPoints, downsample, aggregation)
        }</span>

        <span class="cov8" title="1">return dataPoints</span>
}

func ReadLastDataPoints(id string, count int) []models.DataPoint <span class="cov8" title="1">{

        if checkIfBufferHasEnoughDataPoints(id, count) </span><span class="cov8" title="1">{
                return readLastBufferedDataPoints(id, count)
        }</span>

        <span class="cov8" title="1">dataPoints, err := readLastFiledDataPoints(id, count)
        if err != nil </span><span class="cov0" title="0">{
                utils.Errorln(err)
                return []models.DataPoint{}
        }</span>

        <span class="cov8" title="1">return dataPoints</span>
}

func FlushRemainingDataPoints() <span class="cov8" title="1">{

        //fsync all file handles
        dataFileHandles.Range(func(key string, value *os.File) bool </span><span class="cov8" title="1">{
                value.Sync()
                return true
        }</span>)
        <span class="cov8" title="1">indexFileHandles.Range(func(key string, value *os.File) bool </span><span class="cov8" title="1">{
                value.Sync()
                return true
        }</span>)
}

func FormatDataPoints(dataPoints []models.DataPoint) string <span class="cov8" title="1">{
        var response string

        for i, dp := range dataPoints </span><span class="cov8" title="1">{
                response += fmt.Sprintf("%s,%d,%.2f", dp.ID, dp.Timestamp, dp.Value)
                if i &lt; len(dataPoints)-1 </span><span class="cov8" title="1">{
                        response += "|"
                }</span>
        }

        <span class="cov8" title="1">response += "\n"

        return response</span>
}

// JsonFormatDataPoints
func JsonFormatDataPoints(dataPoints []models.DataPoint) string <span class="cov8" title="1">{
        var response string
        //use json marshal to format the data points
        bytes, _ := json.Marshal(dataPoints)
        response = string(bytes)
        return response
}</span>

func GetAllIds() []string <span class="cov8" title="1">{
        return allIds.Items()
}</span>

func GetAllIdsWithCount() []models.KeyCount <span class="cov8" title="1">{
        keys := allIds.Items()

        var keyCount = []models.KeyCount{}
        for _, key := range keys </span><span class="cov8" title="1">{
                fh := prepareFileHandles(key+".aof", dataFileHandles)
                fileStat, _ := fh.Stat()
                size := int(fileStat.Size() / 16)
                keyCount = append(keyCount, models.KeyCount{Key: key, Count: size})
        }</span>

        <span class="cov8" title="1">return keyCount</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package buffer

import (
        "bufio"
        "encoding/binary"
        "gtsdb/concurrent"
        "gtsdb/models"
        "gtsdb/utils"
        "io"
        "os"
        "strings"
        "sync/atomic"
)

func writeBinary(file *os.File, data ...interface{}) <span class="cov8" title="1">{
        for _, d := range data </span><span class="cov8" title="1">{
                err := binary.Write(file, binary.LittleEndian, d)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Panic(err)
                }</span>
        }
}

func readBinary(reader io.Reader, data ...interface{}) error <span class="cov8" title="1">{
        for _, d := range data </span><span class="cov8" title="1">{
                err := binary.Read(reader, binary.LittleEndian, d)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func storeDataPoints(dataPointId string, dataPoints []models.DataPoint) <span class="cov8" title="1">{
        dataFile := prepareFileHandles(dataPointId+".aof", dataFileHandles)
        indexFile := prepareFileHandles(dataPointId+".idx", indexFileHandles)
        for _, dataPoint := range dataPoints </span><span class="cov8" title="1">{
                writeBinary(dataFile, dataPoint.Timestamp, dataPoint.Value)

                countValue, _ := idToCountMap.Load(dataPointId)
                count := countValue
                count.Add(1)

                if count.Load()%indexInterval == 0 </span><span class="cov8" title="1">{
                        offset, _ := dataFile.Seek(0, io.SeekEnd)
                        offset -= int64(binary.Size(dataPoint.Timestamp) + binary.Size(dataPoint.Value))
                        updateIndexFile(indexFile, dataPoint.Timestamp, offset)
                }</span>
        }
}

func prepareFileHandles(fileName string, handleMap *concurrent.Map[string, *os.File]) *os.File <span class="cov8" title="1">{
        fileInterface, ok := handleMap.Load(fileName)
        if !ok </span><span class="cov8" title="1">{
                var err error
                file, err := os.OpenFile(utils.DataDir+"/"+fileName, os.O_APPEND|os.O_RDWR|os.O_CREATE, 0644)
                if err != nil </span><span class="cov8" title="1">{
                        utils.Panic(err)
                }</span>
                <span class="cov8" title="1">handleMap.Store(fileName, file)

                if strings.HasSuffix(fileName, ".aof") </span><span class="cov8" title="1">{
                        _, ok := idToCountMap.Load(fileName[:len(fileName)-4])
                        if !ok </span><span class="cov8" title="1">{
                                fileInfo, err := file.Stat()
                                if err != nil </span><span class="cov0" title="0">{
                                        utils.Panic(err)
                                }</span>
                                <span class="cov8" title="1">fileLength := fileInfo.Size()
                                count := &amp;atomic.Int64{}
                                count.Store(fileLength / 26)
                                idToCountMap.Store(fileName[:len(fileName)-4], count)</span>
                        }
                }
                <span class="cov8" title="1">return file</span>
        }
        <span class="cov8" title="1">return fileInterface</span>
}

func readLastFiledDataPoints(id string, count int) ([]models.DataPoint, error) <span class="cov8" title="1">{
        file := prepareFileHandles(id+".aof", dataFileHandles)
        reader := bufio.NewReader(file)

        _, err := file.Seek(int64(-16*count), io.SeekEnd)
        if err != nil </span><span class="cov8" title="1">{
                file.Seek(0, io.SeekStart)
        }</span>

        <span class="cov8" title="1">var dataPoints []models.DataPoint
        for </span><span class="cov8" title="1">{
                var timestamp int64
                var value float64
                err := readBinary(reader, &amp;timestamp, &amp;value)
                if err != nil </span><span class="cov8" title="1">{
                        if err == io.EOF </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov0" title="0">utils.Error("Error reading file: %v", err)
                        return nil, err</span>
                }

                <span class="cov8" title="1">dataPoints = append(dataPoints, models.DataPoint{
                        ID:        id,
                        Timestamp: timestamp,
                        Value:     value,
                })</span>
        }

        <span class="cov8" title="1">return dataPoints, nil</span>
}

func updateIndexFile(indexFile *os.File, timestamp int64, offset int64) <span class="cov8" title="1">{
        writeBinary(indexFile, timestamp, offset)
}</span>

func readFiledDataPoints(id string, startTime int64, endTime int64) []models.DataPoint <span class="cov8" title="1">{
        file := prepareFileHandles(id+".aof", dataFileHandles)
        var dataPoints []models.DataPoint
        reader := bufio.NewReader(file)

        indexFilename := id + ".idx"
        indexFileInterface, ok := indexFileHandles.Load(indexFilename)
        if ok </span><span class="cov8" title="1">{
                indexFile := indexFileInterface
                indexReader := bufio.NewReader(indexFile)
                offset := int64(0)

                _, err := indexFile.Seek(0, io.SeekStart)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error("Error seeking index file: %v", err)
                        return nil
                }</span>

                <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                        var timestamp int64
                        var fileOffset int64
                        err := readBinary(indexReader, &amp;timestamp, &amp;fileOffset)
                        if err != nil </span><span class="cov8" title="1">{
                                if err == io.EOF </span><span class="cov8" title="1">{
                                        break</span>
                                } else<span class="cov0" title="0"> {
                                        utils.Error("Error reading index file: %v", err)
                                        return nil
                                }</span>
                        }

                        <span class="cov8" title="1">if timestamp &gt; startTime </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">offset = fileOffset</span>
                }

                <span class="cov8" title="1">_, err = file.Seek(offset, io.SeekStart)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error("Error seeking data file: %v", err)
                        return nil
                }</span>
        } else<span class="cov8" title="1"> {
                _, err := file.Seek(0, io.SeekStart)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error("Error seeking data file: %v", err)
                        return nil
                }</span>
        }

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                var timestamp int64
                var value float64
                err := readBinary(reader, &amp;timestamp, &amp;value)
                if err != nil </span><span class="cov8" title="1">{
                        if err == io.EOF </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov0" title="0">utils.Error("Error reading file: %v", err)
                        return nil</span>
                }

                <span class="cov8" title="1">if timestamp &gt; endTime </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">if timestamp &gt;= startTime &amp;&amp; timestamp &lt;= endTime </span><span class="cov8" title="1">{
                        dataPoints = append(dataPoints, models.DataPoint{
                                ID:        id,
                                Timestamp: timestamp,
                                Value:     value,
                        })
                }</span>
        }

        <span class="cov8" title="1">return dataPoints</span>
}

func readBufferedDataPoints(id string, startTime, endTime int64) []models.DataPoint <span class="cov8" title="1">{
        if cacheSize == 0 </span><span class="cov8" title="1">{
                return []models.DataPoint{}
        }</span>

        <span class="cov8" title="1">rb, ok := idToRingBufferMap.Load(id)
        if !ok </span><span class="cov8" title="1">{
                return []models.DataPoint{}
        }</span>

        <span class="cov8" title="1">var result []models.DataPoint
        for i := 0; i &lt; rb.Size(); i++ </span><span class="cov8" title="1">{
                dataPoint := rb.Get(i)
                dataPoint.ID = id
                if dataPoint.Timestamp &gt;= startTime &amp;&amp; dataPoint.Timestamp &lt;= endTime </span><span class="cov8" title="1">{
                        result = append(result, dataPoint)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

func checkIfBufferHasEnoughDataPoints(id string, count int) bool <span class="cov8" title="1">{
        rb, ok := idToRingBufferMap.Load(id)
        if !ok </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return rb.Size() &gt;= count</span>
}

func readLastBufferedDataPoints(id string, count int) []models.DataPoint <span class="cov8" title="1">{
        if count == 1 &amp;&amp; lastTimestamp[id] != 0 </span><span class="cov8" title="1">{
                return []models.DataPoint{{Timestamp: lastTimestamp[id], Value: lastValue[id], ID: id}}
        }</span>

        <span class="cov8" title="1">rb, ok := idToRingBufferMap.Load(id)
        if !ok </span><span class="cov8" title="1">{
                return []models.DataPoint{}
        }</span>

        <span class="cov8" title="1">if count &gt; rb.Size() </span><span class="cov8" title="1">{
                count = rb.Size()
        }</span>
        <span class="cov8" title="1">if count == 0 </span><span class="cov8" title="1">{
                return []models.DataPoint{}
        }</span>

        <span class="cov8" title="1">result := make([]models.DataPoint, count)
        for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                result[i] = rb.Get(rb.Size() - count + i)
        }</span>
        <span class="cov8" title="1">return result</span>
}

func downsampleDataPoints(dataPoints []models.DataPoint, downsample int, aggregation string) []models.DataPoint <span class="cov8" title="1">{
        if len(dataPoints) == 0 </span><span class="cov8" title="1">{
                return dataPoints
        }</span>

        <span class="cov8" title="1">var downsampled []models.DataPoint
        intervalStart := dataPoints[0].Timestamp
        intervalSum := 0.0
        intervalCount := 0
        intervalMin := dataPoints[0].Value
        intervalMax := dataPoints[0].Value
        intervalFirst := dataPoints[0].Value
        intervalLast := dataPoints[0].Value

        for _, dp := range dataPoints </span><span class="cov8" title="1">{
                if dp.Timestamp-intervalStart &gt;= int64(downsample) </span><span class="cov8" title="1">{
                        if intervalCount &gt; 0 </span><span class="cov8" title="1">{
                                var value float64
                                switch aggregation </span>{
                                case "avg":<span class="cov8" title="1">
                                        value = intervalSum / float64(intervalCount)</span>
                                case "sum":<span class="cov8" title="1">
                                        value = intervalSum</span>
                                case "min":<span class="cov8" title="1">
                                        value = intervalMin</span>
                                case "max":<span class="cov8" title="1">
                                        value = intervalMax</span>
                                case "first":<span class="cov8" title="1">
                                        value = intervalFirst</span>
                                case "last":<span class="cov8" title="1">
                                        value = intervalLast</span>
                                default:<span class="cov8" title="1">
                                        value = intervalSum / float64(intervalCount)</span>
                                }
                                <span class="cov8" title="1">downsampled = append(downsampled, models.DataPoint{
                                        ID:        dp.ID,
                                        Timestamp: intervalStart,
                                        Value:     value,
                                })</span>
                        }
                        <span class="cov8" title="1">intervalStart = dp.Timestamp
                        intervalSum = dp.Value
                        intervalCount = 1
                        intervalMin = dp.Value
                        intervalMax = dp.Value
                        intervalFirst = dp.Value
                        intervalLast = dp.Value</span>
                } else<span class="cov8" title="1"> {
                        intervalSum += dp.Value
                        intervalCount++
                        if dp.Value &lt; intervalMin </span><span class="cov8" title="1">{
                                intervalMin = dp.Value
                        }</span>
                        <span class="cov8" title="1">if dp.Value &gt; intervalMax </span><span class="cov8" title="1">{
                                intervalMax = dp.Value
                        }</span>
                        <span class="cov8" title="1">intervalLast = dp.Value</span>
                }
        }

        <span class="cov8" title="1">if intervalCount &gt; 0 </span><span class="cov8" title="1">{
                var value float64
                switch aggregation </span>{
                case "avg":<span class="cov8" title="1">
                        value = intervalSum / float64(intervalCount)</span>
                case "sum":<span class="cov8" title="1">
                        value = intervalSum</span>
                case "min":<span class="cov8" title="1">
                        value = intervalMin</span>
                case "max":<span class="cov8" title="1">
                        value = intervalMax</span>
                case "first":<span class="cov8" title="1">
                        value = intervalFirst</span>
                case "last":<span class="cov8" title="1">
                        value = intervalLast</span>
                default:<span class="cov8" title="1">
                        value = intervalSum / float64(intervalCount)</span>
                }
                <span class="cov8" title="1">downsampled = append(downsampled, models.DataPoint{
                        ID:        dataPoints[len(dataPoints)-1].ID,
                        Timestamp: intervalStart,
                        Value:     value,
                })</span>
        }

        <span class="cov8" title="1">return downsampled</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package concurrent

import "sync"

type Node[K comparable, V any] struct {
        key        K
        value      V
        prev, next *Node[K, V]
}

type LRU[K comparable, V any] struct {
        capacity int
        cache    map[K]*Node[K, V]
        head     *Node[K, V]
        tail     *Node[K, V]
        mutex    sync.Mutex
}

func NewLRU[K comparable, V any](capacity int) *LRU[K, V] <span class="cov8" title="1">{
        return &amp;LRU[K, V]{
                capacity: capacity,
                cache:    make(map[K]*Node[K, V]),
                head:     nil,
                tail:     nil,
                mutex:    sync.Mutex{},
        }
}</span>

func (l *LRU[K, V]) Get(key K) (V, bool) <span class="cov8" title="1">{
        l.mutex.Lock()
        defer l.mutex.Unlock()

        if node, exists := l.cache[key]; exists </span><span class="cov8" title="1">{
                l.moveToFront(node)
                return node.value, true
        }</span>
        <span class="cov8" title="1">var zero V
        return zero, false</span>
}

func (l *LRU[K, V]) Put(key K, value V) <span class="cov8" title="1">{
        l.mutex.Lock()
        defer l.mutex.Unlock()

        if node, exists := l.cache[key]; exists </span><span class="cov8" title="1">{
                node.value = value
                l.moveToFront(node)
                return
        }</span>

        <span class="cov8" title="1">newNode := &amp;Node[K, V]{key: key, value: value}
        l.cache[key] = newNode

        if len(l.cache) == 1 </span><span class="cov8" title="1">{
                l.head = newNode
                l.tail = newNode
        }</span> else<span class="cov8" title="1"> {
                newNode.next = l.head
                l.head.prev = newNode
                l.head = newNode
        }</span>

        <span class="cov8" title="1">if len(l.cache) &gt; l.capacity </span><span class="cov8" title="1">{
                delete(l.cache, l.tail.key)
                l.tail = l.tail.prev
                l.tail.next = nil
        }</span>
}

func (l *LRU[K, V]) moveToFront(node *Node[K, V]) <span class="cov8" title="1">{
        if node == l.head </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if node == l.tail </span><span class="cov8" title="1">{
                l.tail = node.prev
                l.tail.next = nil
        }</span> else<span class="cov0" title="0"> {
                node.prev.next = node.next
                node.next.prev = node.prev
        }</span>

        <span class="cov8" title="1">node.prev = nil
        node.next = l.head
        l.head.prev = node
        l.head = node</span>
}

func (l *LRU[K, V]) Len() int <span class="cov8" title="1">{
        l.mutex.Lock()
        defer l.mutex.Unlock()
        return len(l.cache)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package concurrent

import "sync"

type Map[K comparable, V any] struct {
        internal sync.Map
}

// NewMap creates a new concurrent Map
func NewMap[K comparable, V any]() *Map[K, V] <span class="cov8" title="1">{
        return &amp;Map[K, V]{}
}</span>

// Store sets the value for a key
func (m *Map[K, V]) Store(key K, value V) <span class="cov8" title="1">{
        m.internal.Store(key, value)
}</span>

// Load retrieves the value for a key
func (m *Map[K, V]) Load(key K) (V, bool) <span class="cov8" title="1">{
        value, ok := m.internal.Load(key)
        if !ok </span><span class="cov8" title="1">{
                var zero V
                return zero, false
        }</span>
        <span class="cov8" title="1">return value.(V), true</span>
}

// Delete removes a key from the map
func (m *Map[K, V]) Delete(key K) <span class="cov8" title="1">{
        m.internal.Delete(key)
}</span>

// LoadOrStore returns the existing value for the key if present.
// Otherwise, it stores and returns the given value.
func (m *Map[K, V]) LoadOrStore(key K, value V) (V, bool) <span class="cov8" title="1">{
        actual, loaded := m.internal.LoadOrStore(key, value)
        return actual.(V), loaded
}</span>

// Range calls f sequentially for each key and value in the map.
func (m *Map[K, V]) Range(f func(key K, value V) bool) <span class="cov8" title="1">{
        m.internal.Range(func(key, value interface{}) bool </span><span class="cov8" title="1">{
                return f(key.(K), value.(V))
        }</span>)
}

// Clear removes all items from the map
func (m *Map[K, V]) Clear() <span class="cov8" title="1">{
        m.Range(func(key K, value V) bool </span><span class="cov8" title="1">{
                m.Delete(key)
                return true
        }</span>)
}

// Size returns the number of items in the map
func (m *Map[K, V]) Size() int <span class="cov8" title="1">{
        count := 0
        m.Range(func(K, V) bool </span><span class="cov8" title="1">{
                count++
                return true
        }</span>)
        <span class="cov8" title="1">return count</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package concurrent

import (
        "sync"
)

// Set represents a thread-safe set data structure
type Set[T comparable] struct {
        sync.RWMutex
        items map[T]struct{}
}

// NewSet creates a new Set
func NewSet[T comparable]() *Set[T] <span class="cov8" title="1">{
        return &amp;Set[T]{
                items: make(map[T]struct{}),
        }
}</span>

// Add adds an item to the set
func (s *Set[T]) Add(item T) <span class="cov8" title="1">{
        s.Lock()
        defer s.Unlock()
        s.items[item] = struct{}{}
}</span>

// Remove removes an item from the set
func (s *Set[T]) Remove(item T) <span class="cov8" title="1">{
        s.Lock()
        defer s.Unlock()
        delete(s.items, item)
}</span>

// Contains checks if an item exists in the set
func (s *Set[T]) Contains(item T) bool <span class="cov8" title="1">{
        s.RLock()
        defer s.RUnlock()
        _, exists := s.items[item]
        return exists
}</span>

// Size returns the number of items in the set
func (s *Set[T]) Size() int <span class="cov8" title="1">{
        s.RLock()
        defer s.RUnlock()
        return len(s.items)
}</span>

// Clear removes all items from the set
func (s *Set[T]) Clear() <span class="cov8" title="1">{
        s.Lock()
        defer s.Unlock()
        s.items = make(map[T]struct{})
}</span>

// Items returns a slice of all items in the set
func (s *Set[T]) Items() []T <span class="cov8" title="1">{
        s.RLock()
        defer s.RUnlock()
        items := make([]T, 0, len(s.items))
        for item := range s.items </span><span class="cov8" title="1">{
                items = append(items, item)
        }</span>
        <span class="cov8" title="1">return items</span>
}

func (s *Set[T]) ForEach(fn func(item T)) <span class="cov8" title="1">{
        s.RLock()
        defer s.RUnlock()
        for item := range s.items </span><span class="cov8" title="1">{
                fn(item)
        }</span>
}

// Union returns a new set containing all elements from both sets
func (s *Set[T]) Union(other *Set[T]) *Set[T] <span class="cov8" title="1">{
        result := NewSet[T]()
        s.RLock()
        other.RLock()
        defer s.RUnlock()
        defer other.RUnlock()

        for item := range s.items </span><span class="cov8" title="1">{
                result.items[item] = struct{}{}
        }</span>
        <span class="cov8" title="1">for item := range other.items </span><span class="cov8" title="1">{
                result.items[item] = struct{}{}
        }</span>

        <span class="cov8" title="1">return result</span>
}

// Intersection returns a new set containing elements present in both sets
func (s *Set[T]) Intersection(other *Set[T]) *Set[T] <span class="cov8" title="1">{
        result := NewSet[T]()
        s.RLock()
        other.RLock()
        defer s.RUnlock()
        defer other.RUnlock()

        for item := range s.items </span><span class="cov8" title="1">{
                if _, exists := other.items[item]; exists </span><span class="cov8" title="1">{
                        result.items[item] = struct{}{}
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package fanout

import (
        models "gtsdb/models"
        "sync"
)

type Consumer struct {
        ID       int
        Callback func(models.DataPoint)
}

type Fanout struct {
        consumers []*Consumer
        messageCh chan models.DataPoint
        mu        sync.RWMutex
        wg        sync.WaitGroup
}

func NewFanout() *Fanout <span class="cov8" title="1">{
        fanoutManager := &amp;Fanout{
                consumers: make([]*Consumer, 0),
                messageCh: make(chan models.DataPoint),
        }
        go fanoutManager.producer()
        return fanoutManager
}</span>

func (f *Fanout) AddConsumer(id int, callback func(models.DataPoint)) <span class="cov8" title="1">{
        f.mu.Lock()
        defer f.mu.Unlock()
        consumer := &amp;Consumer{ID: id, Callback: callback}
        f.consumers = append(f.consumers, consumer)
        f.wg.Add(1)
}</span>

func (f *Fanout) GetConsumers() []*Consumer <span class="cov8" title="1">{
        f.mu.RLock()
        defer f.mu.RUnlock()
        return f.consumers
}</span>

func (f *Fanout) RemoveConsumer(id int) <span class="cov8" title="1">{
        f.mu.Lock()
        defer f.mu.Unlock()
        for i, c := range f.consumers </span><span class="cov8" title="1">{
                if c.ID == id </span><span class="cov8" title="1">{
                        f.consumers = append(f.consumers[:i], f.consumers[i+1:]...)
                        f.wg.Done()
                        break</span>
                }
        }
}

func (f *Fanout) Publish(msg models.DataPoint) <span class="cov8" title="1">{
        f.messageCh &lt;- msg
}</span>

func (f *Fanout) producer() <span class="cov8" title="1">{
        for msg := range f.messageCh </span><span class="cov8" title="1">{
                f.mu.RLock()
                for _, c := range f.consumers </span><span class="cov8" title="1">{
                        go c.Callback(msg)
                }</span>
                <span class="cov8" title="1">f.mu.RUnlock()</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "gtsdb/buffer"
        "gtsdb/fanout"
        "gtsdb/handlers"
        "gtsdb/utils"
        "net"
        "net/http"
        "os"
        "os/signal"
        "time"

        "gopkg.in/ini.v1"
)

func main() <span class="cov0" title="0">{
        run("gtsdb.ini")
}</span>

func run(configFile string) <span class="cov8" title="1">{
        loadConfig(configFile)
        utils.InitDataDirectory()
        fanoutManager := fanout.NewFanout()

        // Create stop channels
        tcpStop := make(chan struct{})
        httpStop := make(chan struct{})

        go startTCPServerWithStop(fanoutManager, tcpStop)
        go startHTTPServerWithStop(fanoutManager, httpStop)

        c := make(chan os.Signal, 1)
        signal.Notify(c, os.Interrupt)
        &lt;-c

        // Stop servers
        close(tcpStop)
        close(httpStop)
        gracefulShutdown()
}</span>

func startTCPServerWithStop(fanoutManager *fanout.Fanout, stop chan struct{}) <span class="cov8" title="1">{
        listener, err := net.Listen("tcp", utils.TcpListenAddr)
        if err != nil </span><span class="cov0" title="0">{
                utils.Errorln("Error listening:", err)
                return
        }</span>
        <span class="cov8" title="1">defer listener.Close()

        go func() </span><span class="cov8" title="1">{
                &lt;-stop
                listener.Close()
        }</span>()

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                conn, err := listener.Accept()
                if err != nil </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-stop:<span class="cov8" title="1">
                                return</span>
                        default:<span class="cov0" title="0">
                                utils.Errorln("Error accepting connection:", err)
                                continue</span>
                        }
                }
                <span class="cov8" title="1">go handlers.HandleTcpConnection(conn, fanoutManager)</span>
        }
}

func startHTTPServerWithStop(fanoutManager *fanout.Fanout, stop chan struct{}) <span class="cov8" title="1">{
        srv := &amp;http.Server{
                Addr:    utils.HttpListenAddr,
                Handler: handlers.SetupHTTPRoutes(fanoutManager),
        }

        go func() </span><span class="cov8" title="1">{
                &lt;-stop
                srv.Close()
        }</span>()

        <span class="cov8" title="1">srv.ListenAndServe()</span>
}

func loadConfig(iniFile string) <span class="cov8" title="1">{
        utils.Logln("Ê≠°Ëøé‰ΩøÁî®üêπÂ∞èÂÄâÈº†üêπÊôÇÂ∫èË≥áÊñôÂ∫´ üêÅüêÅ ")
        utils.Logln("üé∂Âê±Âê±üé∂Âê±Âê±üé∂ üêπ")
        utils.Logln("üèÉË∑ëüèÉË∑ëË∑ëË∑ëüèÉ üêπ")
        utils.Log("‰ªäÂ§©ÊòØÔºö%s Âì¶", time.Now().Format("2006-01-02 15:04:05"))

        cfg, err := ini.Load(iniFile)
        if err != nil </span><span class="cov8" title="1">{
                utils.Warningln("ÁÑ°Ê≥ïËÆÄÂèñÈÖçÁΩÆÊñá‰ª∂Ôºö", err)
        }</span> else<span class="cov8" title="1"> {
                utils.TcpListenAddr = cfg.Section("listens").Key("tcp").String()
                utils.HttpListenAddr = cfg.Section("listens").Key("http").String()
                utils.DataDir = cfg.Section("paths").Key("data").String()
        }</span>

        <span class="cov8" title="1">utils.Logln(" TCP Áõ£ËÅΩÂú∞ÂùÄÔºö ", utils.TcpListenAddr)
        utils.Logln("HTTP Áõ£ËÅΩÂú∞ÂùÄÔºö ", utils.HttpListenAddr)
        utils.Logln(" Êï∏ÊìöÂ≠òÂÑ≤ÁõÆÈåÑÔºö ", utils.DataDir)

        buffer.InitIDSet()

        utils.Log("üìä ÊàëÂÄëÁèæÂú®Êúâ %d ÁµÑÊôÇÂ∫è", len(buffer.GetAllIds()))</span>
}

func gracefulShutdown() <span class="cov8" title="1">{
        utils.Logln("‰∏≠Êñ∑‰ø°Ëôü‰æÜ‰∫ÜÔºÅÂ∞èÂÄâÈº†Ë¶ÅÂÖàÊääÊâÄÊúâÊï∏ÊìöÂ≠òÂ•Ω...Âê±Âê±")
        buffer.FlushRemainingDataPoints()
        utils.Logln("ÂÆâÂÖ®ÊîæÂ•ΩÈ£üÁâ©ÂõûÂÆ∂‰∫ÜÂï¶ÔºÅÊãúÊãúÔºÅ‰∏ãÊ¨°‰æÜÁé©ÂñîÔºÅ")
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package synchronous

type RingBuffer[T any] struct {
        buffer []T
        size   int
        head   int
        tail   int
}

func NewRingBuffer[T any](capacity int) *RingBuffer[T] <span class="cov8" title="1">{
        return &amp;RingBuffer[T]{
                buffer: make([]T, capacity),
                size:   0,
                head:   0,
                tail:   0,
        }
}</span>

func (rb *RingBuffer[T]) Push(item T) <span class="cov8" title="1">{
        rb.buffer[rb.tail] = item
        rb.tail = (rb.tail + 1) % len(rb.buffer)
        if rb.size &lt; len(rb.buffer) </span><span class="cov8" title="1">{
                rb.size++
        }</span> else<span class="cov8" title="1"> {
                rb.head = (rb.head + 1) % len(rb.buffer)
        }</span>
}

func (rb *RingBuffer[T]) Get(index int) T <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= rb.size </span><span class="cov8" title="1">{
                panic("Index out of bounds")</span>
        }
        <span class="cov8" title="1">pos := (rb.head + index) % len(rb.buffer)
        return rb.buffer[pos]</span>
}

func (rb *RingBuffer[T]) GetAll() []T <span class="cov8" title="1">{
        result := make([]T, rb.size)
        for i := 0; i &lt; rb.size; i++ </span><span class="cov8" title="1">{
                result[i] = rb.Get(i)
        }</span>
        <span class="cov8" title="1">return result</span>
}

func (rb *RingBuffer[T]) Size() int <span class="cov8" title="1">{
        return rb.size
}</span>

func (rb *RingBuffer[T]) Capacity() int <span class="cov0" title="0">{
        return len(rb.buffer)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package utils

import (
        "fmt"
        "os"
        "time"
)

var (
        TcpListenAddr  = ":5555"
        HttpListenAddr = ":5556"
        DataDir        = "data"
)

func dateString() string <span class="cov8" title="1">{
        return time.Now().Format("2006-01-02 15:04:05")
}</span>
func InitDataDirectory() <span class="cov8" title="1">{
        //if dataDir does not exist, create it
        if _, err := os.Stat(DataDir); os.IsNotExist(err) </span><span class="cov8" title="1">{
                err := os.Mkdir(DataDir, 0755)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error creating data directory:", err)
                        os.Exit(1)
                }</span>
        }
}

func Log(message string, args ...interface{}) <span class="cov8" title="1">{
        fmt.Printf("[%s] üêπ %s\n", dateString(), fmt.Sprintf(message, args...))
}</span>

func Error(message string, args ...interface{}) <span class="cov8" title="1">{
        fmt.Printf("[%s] üò° %s\n", dateString(), fmt.Sprintf(message, args...))
}</span>

func Warning(message string, args ...interface{}) <span class="cov8" title="1">{
        fmt.Printf("[%s] üòü %s\n", dateString(), fmt.Sprintf(message, args...))
}</span>

func Debug(message string, args ...interface{}) <span class="cov8" title="1">{
        fmt.Printf("[%s] üîçüêπ %s\n", dateString(), fmt.Sprintf(message, args...))
}</span>

func Logln(messages ...interface{}) <span class="cov8" title="1">{
        fmt.Printf("[%s] üêπ %s\n", dateString(), fmt.Sprint(messages...))
}</span>

func Errorln(messages ...interface{}) <span class="cov8" title="1">{
        fmt.Printf("[%s] üò° %s\n", dateString(), fmt.Sprint(messages...))
}</span>

func Warningln(messages ...interface{}) <span class="cov8" title="1">{
        fmt.Printf("[%s] üòü %s\n", dateString(), fmt.Sprint(messages...))
}</span>

func Debugln(messages ...interface{}) <span class="cov8" title="1">{
        fmt.Printf("[%s] üîçüêπ %s\n", dateString(), fmt.Sprint(messages...))
}</span>

func Panic(v any) <span class="cov8" title="1">{
        fmt.Printf("[%s] üö®üêπüö® \n", dateString()) //ÊàëË¢´Ë≠¶ËªäÂåÖÂúç‰∫Ü!
        panic(v)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
