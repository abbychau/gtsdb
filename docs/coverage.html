
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>buffer: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">gtsdb/buffer/engine.go (54.2%)</option>
				
				<option value="file1">gtsdb/buffer/storage.go (79.7%)</option>
				
				<option value="file2">gtsdb/concurrent/hashmap.go (71.4%)</option>
				
				<option value="file3">gtsdb/concurrent/lru.go (100.0%)</option>
				
				<option value="file4">gtsdb/concurrent/set.go (91.3%)</option>
				
				<option value="file5">gtsdb/fanout/fanout.go (61.9%)</option>
				
				<option value="file6">gtsdb/handlers/common.go (92.0%)</option>
				
				<option value="file7">gtsdb/handlers/httpHandler.go (0.0%)</option>
				
				<option value="file8">gtsdb/handlers/tcpHandler.go (0.0%)</option>
				
				<option value="file9">gtsdb/main.go (0.0%)</option>
				
				<option value="file10">gtsdb/synchronous/ringbuffer.go (93.8%)</option>
				
				<option value="file11">gtsdb/utils/utils.go (38.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package buffer

import (
        "bufio"
        "encoding/json"
        "fmt"
        "gtsdb/models"
        "gtsdb/utils"
        "io"
        "os"
        "strconv"
        "strings"
)

func readMetaCount(metaFile *os.File) int <span class="cov8" title="1">{
        _, err := metaFile.Seek(0, io.SeekStart)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">scanner := bufio.NewScanner(metaFile)
        if scanner.Scan() </span><span class="cov8" title="1">{
                countStr := strings.TrimPrefix(scanner.Text(), "count:")
                count, _ := strconv.Atoi(countStr)
                return count
        }</span>

        <span class="cov8" title="1">return 0</span>
}

func writeMetaCount(metaFile *os.File, count int) <span class="cov8" title="1">{
        _, err := metaFile.Seek(0, io.SeekStart)
        if err != nil </span><span class="cov0" title="0">{
                utils.Errorln("Error seeking meta file:", err)
                return
        }</span>
        <span class="cov8" title="1">str := fmt.Sprintf("count:%d\n", count)
        //empty the file
        metaFile.Truncate(0)
        metaFile.Seek(0, io.SeekStart)
        metaFile.WriteString(str)</span>
}

func updateIndexFile(indexFile *os.File, timestamp int64, offset int64) <span class="cov0" title="0">{
        line := fmt.Sprintf("%d,%d\n", timestamp, offset)
        indexFile.WriteString(line)
}</span>
func dataFileById(id string) *os.File <span class="cov8" title="1">{
        filename := id + ".aof"

        file, ok := dataFileHandles.Get(filename)
        if !ok </span><span class="cov8" title="1">{
                var err error
                file, err = os.OpenFile(utils.DataDir+"/"+filename, os.O_APPEND|os.O_RDWR|os.O_CREATE, 0644)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error("Error opening file: %v", err)
                        return nil
                }</span>
                <span class="cov8" title="1">dataFileHandles.Set(filename, file)</span>
        }
        <span class="cov8" title="1">return file</span>
}
func ReadDataPoints(id string, startTime, endTime int64, downsample int, aggregation string) []models.DataPoint <span class="cov8" title="1">{

        dataPoints := readBufferedDataPoints(id, startTime, endTime)
        if len(dataPoints) == 0 </span><span class="cov8" title="1">{
                dataPoints = readFiledDataPoints(id, startTime, endTime)
        }</span>

        <span class="cov8" title="1">if downsample &gt; 1 </span><span class="cov8" title="1">{
                dataPoints = downsampleDataPoints(dataPoints, downsample, aggregation)
        }</span>

        <span class="cov8" title="1">return dataPoints</span>
}

func readFiledDataPoints(id string, startTime, endTime int64) []models.DataPoint <span class="cov8" title="1">{
        file := dataFileById(id)
        var dataPoints []models.DataPoint
        reader := bufio.NewReader(file)

        indexFilename := id + ".idx"
        indexFile, ok := indexFileHandles.Get(indexFilename)
        if ok </span><span class="cov0" title="0">{
                indexReader := bufio.NewReader(indexFile)
                var offset int64

                _, err := indexFile.Seek(0, io.SeekStart)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error("Error seeking index file: %v", err)
                        return nil
                }</span>

                <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                        line, err := indexReader.ReadString('\n')
                        if err != nil </span><span class="cov0" title="0">{
                                break</span>
                        }

                        <span class="cov0" title="0">parts := strings.Split(strings.TrimSpace(line), ",")
                        timestamp, _ := strconv.ParseInt(parts[0], 10, 64)
                        if timestamp &gt; startTime </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">offset, _ = strconv.ParseInt(parts[1], 10, 64)</span>
                }

                <span class="cov0" title="0">_, err = file.Seek(offset, io.SeekStart)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error("Error seeking data file: %v", err)
                        return nil
                }</span>
        } else<span class="cov8" title="1"> {
                _, err := file.Seek(0, io.SeekStart)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error("Error seeking data file: %v", err)
                        return nil
                }</span>
        }

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                line, err := reader.ReadString('\n')
                if err != nil </span><span class="cov8" title="1">{
                        if err == io.EOF </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov0" title="0">utils.Error("Error reading file: %v", err)
                        return nil</span>
                }

                <span class="cov8" title="1">parts := strings.Split(strings.TrimSpace(line), ",")
                timestamp, _ := strconv.ParseInt(parts[0], 10, 64)
                value, _ := strconv.ParseFloat(parts[1], 64)

                if timestamp &gt; endTime </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">if timestamp &gt;= startTime &amp;&amp; timestamp &lt;= endTime </span><span class="cov8" title="1">{
                        dataPoints = append(dataPoints, models.DataPoint{
                                ID:        id,
                                Timestamp: timestamp,
                                Value:     value,
                        })
                }</span>
        }

        <span class="cov8" title="1">return dataPoints</span>
}

func ReadLastDataPoints(id string, count int) []models.DataPoint <span class="cov0" title="0">{

        dataPoints := readLastBufferedDataPoints(id, count)
        fmt.Println("dataPoints", dataPoints)
        fmt.Println("Count", count)
        if len(dataPoints) &lt; count </span><span class="cov0" title="0">{

                remaining := count - len(dataPoints)
                lastDataPoints, err := readLastFiledDataPoints(id, remaining)
                if err == nil </span><span class="cov0" title="0">{
                        dataPoints = append(dataPoints, lastDataPoints...)
                }</span>
        }

        <span class="cov0" title="0">return dataPoints</span>
}

func readLastFiledDataPoints(id string, count int) ([]models.DataPoint, error) <span class="cov0" title="0">{
        file := dataFileById(id)
        reader := bufio.NewReader(file)

        //seek the last x bytes using offset
        // line width is "1731690356,3.33333330e+03" 25 + 1 (\n) = 32
        // 26 * count
        _, err := file.Seek(int64(-26*count), io.SeekEnd)
        if err != nil </span><span class="cov0" title="0">{
                //if the file is smaller than the offset, seek to the beginning
                file.Seek(0, io.SeekStart)
        }</span>

        <span class="cov0" title="0">var dataPoints []models.DataPoint
        for </span><span class="cov0" title="0">{
                line, err := reader.ReadString('\n')
                if err != nil </span><span class="cov0" title="0">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">utils.Error("Error reading file: %v", err)
                        return nil, err</span>
                }

                <span class="cov0" title="0">parts := strings.Split(strings.TrimSpace(line), ",")
                trimmedTimestamp := strings.TrimSpace(parts[0])
                timestamp, _ := strconv.ParseInt(trimmedTimestamp, 10, 64)
                trimmedValue := strings.TrimSpace(parts[1])
                value, _ := strconv.ParseFloat(trimmedValue, 64)

                dataPoints = append(dataPoints, models.DataPoint{
                        ID:        id,
                        Timestamp: timestamp,
                        Value:     value,
                })</span>
        }

        <span class="cov0" title="0">return dataPoints, nil</span>
}

func downsampleDataPoints(dataPoints []models.DataPoint, downsample int, aggregation string) []models.DataPoint <span class="cov8" title="1">{
        if len(dataPoints) == 0 </span><span class="cov0" title="0">{
                return dataPoints
        }</span>

        <span class="cov8" title="1">var downsampled []models.DataPoint
        intervalStart := dataPoints[0].Timestamp
        intervalSum := 0.0
        intervalCount := 0
        var intervalMin, intervalMax, intervalFirst, intervalLast float64
        intervalFirst = dataPoints[0].Value

        for _, dp := range dataPoints </span><span class="cov8" title="1">{
                if dp.Timestamp-intervalStart &gt;= int64(downsample) </span><span class="cov8" title="1">{
                        // Reached the end of the current interval
                        if intervalCount &gt; 0 </span><span class="cov8" title="1">{
                                var value float64
                                switch aggregation </span>{
                                case "avg":<span class="cov8" title="1">
                                        value = intervalSum / float64(intervalCount)</span>
                                case "sum":<span class="cov0" title="0">
                                        value = intervalSum</span>
                                case "min":<span class="cov0" title="0">
                                        value = intervalMin</span>
                                case "max":<span class="cov0" title="0">
                                        value = intervalMax</span>
                                case "first":<span class="cov0" title="0">
                                        value = intervalFirst</span>
                                case "last":<span class="cov0" title="0">
                                        value = intervalLast</span>
                                default:<span class="cov0" title="0">
                                        value = intervalSum / float64(intervalCount)</span>
                                }
                                <span class="cov8" title="1">downsampled = append(downsampled, models.DataPoint{
                                        ID:        dp.ID,
                                        Timestamp: intervalStart,
                                        Value:     value,
                                })</span>
                        }
                        // Start a new interval
                        <span class="cov8" title="1">intervalStart = dp.Timestamp
                        intervalSum = dp.Value
                        intervalCount = 1
                        intervalMin = dp.Value
                        intervalMax = dp.Value
                        intervalFirst = dp.Value
                        intervalLast = dp.Value</span>
                } else<span class="cov8" title="1"> {
                        // Accumulate values within the current interval
                        intervalSum += dp.Value
                        intervalCount++
                        if dp.Value &lt; intervalMin </span><span class="cov0" title="0">{
                                intervalMin = dp.Value
                        }</span>
                        <span class="cov8" title="1">if dp.Value &gt; intervalMax </span><span class="cov8" title="1">{
                                intervalMax = dp.Value
                        }</span>
                        <span class="cov8" title="1">intervalLast = dp.Value</span>
                }
        }

        // Process the last interval
        <span class="cov8" title="1">if intervalCount &gt; 0 </span><span class="cov8" title="1">{
                var value float64
                switch aggregation </span>{
                case "avg":<span class="cov8" title="1">
                        value = intervalSum / float64(intervalCount)</span>
                case "sum":<span class="cov0" title="0">
                        value = intervalSum</span>
                case "min":<span class="cov0" title="0">
                        value = intervalMin</span>
                case "max":<span class="cov8" title="1">
                        value = intervalMax</span>
                case "first":<span class="cov0" title="0">
                        value = intervalFirst</span>
                case "last":<span class="cov0" title="0">
                        value = intervalLast</span>
                default:<span class="cov0" title="0">
                        value = intervalSum / float64(intervalCount)</span>
                }
                <span class="cov8" title="1">downsampled = append(downsampled, models.DataPoint{
                        ID:        dataPoints[len(dataPoints)-1].ID,
                        Timestamp: intervalStart,
                        Value:     value,
                })</span>
        }

        <span class="cov8" title="1">return downsampled</span>
}

func FormatDataPoints(dataPoints []models.DataPoint) string <span class="cov8" title="1">{
        var response string

        for i, dp := range dataPoints </span><span class="cov8" title="1">{
                response += fmt.Sprintf("%s,%d,%.2f", dp.ID, dp.Timestamp, dp.Value)
                if i &lt; len(dataPoints)-1 </span><span class="cov8" title="1">{
                        response += "|"
                }</span>
        }

        <span class="cov8" title="1">response += "\n"

        return response</span>
}

// JsonFormatDataPoints
func JsonFormatDataPoints(dataPoints []models.DataPoint) string <span class="cov0" title="0">{
        var response string
        //use json marshal to format the data points
        bytes, _ := json.Marshal(dataPoints)
        response = string(bytes)
        return response
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package buffer

import (
        "fmt"
        "gtsdb/concurrent"
        "gtsdb/models"
        "gtsdb/synchronous"
        "gtsdb/utils"
        "io"
        "os"
)

func StoreDataPointBuffer(dataPoint models.DataPoint) <span class="cov8" title="1">{
        if cacheSize == 0 </span><span class="cov0" title="0">{
                storeDataPoints(dataPoint.ID, []models.DataPoint{dataPoint})
                return
        }</span>

        <span class="cov8" title="1">rb, ok := idToRingBufferMap.Get(dataPoint.ID)
        if !ok </span><span class="cov8" title="1">{
                rb = synchronous.NewRingBuffer[models.DataPoint](cacheSize)
                idToRingBufferMap.Set(dataPoint.ID, rb)
        }</span>
        <span class="cov8" title="1">rb.Push(dataPoint)

        storeDataPoints(dataPoint.ID, []models.DataPoint{dataPoint})
        lastValue[dataPoint.ID] = dataPoint.Value
        lastTimestamp[dataPoint.ID] = dataPoint.Timestamp</span>
}

func readBufferedDataPoints(id string, startTime, endTime int64) []models.DataPoint <span class="cov8" title="1">{
        if cacheSize == 0 </span><span class="cov0" title="0">{
                return []models.DataPoint{}
        }</span>

        <span class="cov8" title="1">rb, ok := idToRingBufferMap.Get(id)
        if !ok </span><span class="cov8" title="1">{
                return []models.DataPoint{}
        }</span>

        <span class="cov8" title="1">var result []models.DataPoint
        for i := 0; i &lt; rb.Size(); i++ </span><span class="cov8" title="1">{
                dataPoint := rb.Get(i)
                if dataPoint.Timestamp &gt;= startTime &amp;&amp; dataPoint.Timestamp &lt;= endTime </span><span class="cov8" title="1">{
                        result = append(result, dataPoint)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

func readLastBufferedDataPoints(id string, count int) []models.DataPoint <span class="cov8" title="1">{
        if count == 1 &amp;&amp; lastTimestamp[id] != 0 </span><span class="cov0" title="0">{
                return []models.DataPoint{{Timestamp: lastTimestamp[id], Value: lastValue[id]}}
        }</span>

        <span class="cov8" title="1">rb, ok := idToRingBufferMap.Get(id)
        if !ok </span><span class="cov0" title="0">{
                return []models.DataPoint{}
        }</span>

        <span class="cov8" title="1">if count &gt; rb.Size() </span><span class="cov0" title="0">{
                count = rb.Size()
        }</span>
        <span class="cov8" title="1">if count == 0 </span><span class="cov0" title="0">{
                return []models.DataPoint{}
        }</span>

        <span class="cov8" title="1">result := make([]models.DataPoint, count)
        for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                result[i] = rb.Get(rb.Size() - count + i)
        }</span>
        <span class="cov8" title="1">return result</span>
}

func storeDataPoints(dataPointId string, dataPoints []models.DataPoint) <span class="cov8" title="1">{
        dataFile := prepareFileHandles(dataPointId+".aof", dataFileHandles)
        metaFile := prepareFileHandles(dataPointId+".meta", metaFileHandles)
        indexFile := prepareFileHandles(dataPointId+".idx", indexFileHandles)
        for _, dataPoint := range dataPoints </span><span class="cov8" title="1">{

                line := fmt.Sprintf("%d,%.8e\n", dataPoint.Timestamp, dataPoint.Value)
                dataFile.WriteString(line)
                count := readMetaCount(metaFile)
                count++
                writeMetaCount(metaFile, count)

                if count%indexInterval == 0 </span><span class="cov0" title="0">{

                        //end position of this file
                        offset, _ := dataFile.Seek(0, io.SeekEnd)
                        offset -= int64(len(line))
                        updateIndexFile(indexFile, dataPoint.Timestamp, offset)
                }</span>
        }

}
func prepareFileHandles(fileName string, handleArray *concurrent.HashMap[string, *os.File]) *os.File <span class="cov8" title="1">{

        file, ok := handleArray.Get(fileName)
        if !ok </span><span class="cov8" title="1">{
                var err error
                file, err = os.OpenFile(utils.DataDir+"/"+fileName, os.O_APPEND|os.O_RDWR|os.O_CREATE, 0644)

                if err != nil </span><span class="cov0" title="0">{
                        file, err = os.OpenFile("../"+utils.DataDir+"/"+fileName, os.O_APPEND|os.O_RDWR|os.O_CREATE, 0644) //this is for go test //TODO: any better way?
                        if err != nil </span><span class="cov0" title="0">{
                                panic(err)</span>
                        }
                }
                <span class="cov8" title="1">handleArray.Set(fileName, file)</span>
        }
        <span class="cov8" title="1">return file</span>
}

func FlushRemainingDataPoints() <span class="cov8" title="1">{

        //fsync all file handles
        for _, file := range dataFileHandles.Values() </span><span class="cov8" title="1">{
                file.Sync()
        }</span>
        <span class="cov8" title="1">for _, file := range metaFileHandles.Values() </span><span class="cov8" title="1">{
                file.Sync()
        }</span>
        <span class="cov8" title="1">for _, file := range indexFileHandles.Values() </span><span class="cov8" title="1">{
                file.Sync()
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package concurrent

//üêπüêπüêπüêπüêπüêπüêπüêπüêπüêπüêπüêπüêπüêπüêπüêπüêπüêπüêπüêπüêπ
import "sync"

// HashMap represents a thread-safe generic map structure
type HashMap[K comparable, V any] struct {
        sync.RWMutex
        items map[K]V
}

// NewHashMap creates and initializes a new HashMap
func NewHashMap[K comparable, V any]() *HashMap[K, V] <span class="cov8" title="1">{
        return &amp;HashMap[K, V]{
                items: make(map[K]V),
        }
}</span>

// Put adds or updates an element in the map
func (h *HashMap[K, V]) Put(key K, value V) <span class="cov8" title="1">{
        h.Lock()
        defer h.Unlock()
        h.items[key] = value
}</span>

// Set (alias of Put)
func (h *HashMap[K, V]) Set(key K, value V) <span class="cov0" title="0">{
        h.Put(key, value)
}</span>

// Get retrieves an element from the map
func (h *HashMap[K, V]) Get(key K) (V, bool) <span class="cov8" title="1">{
        h.RLock()
        defer h.RUnlock()
        value, exists := h.items[key]
        return value, exists
}</span>

func (h *HashMap[K, V]) AssertGet(key K) V <span class="cov0" title="0">{
        h.RLock()
        defer h.RUnlock()
        return h.items[key]
}</span>

// Delete removes an element from the map
func (h *HashMap[K, V]) Delete(key K) <span class="cov8" title="1">{
        h.Lock()
        defer h.Unlock()
        delete(h.items, key)
}</span>

// Contains checks if a key exists in the map
func (h *HashMap[K, V]) Contains(key K) bool <span class="cov8" title="1">{
        h.RLock()
        defer h.RUnlock()
        _, exists := h.items[key]
        return exists
}</span>

// Size returns the number of elements in the map
func (h *HashMap[K, V]) Size() int <span class="cov8" title="1">{
        h.RLock()
        defer h.RUnlock()
        return len(h.items)
}</span>

// Clear removes all elements from the map
func (h *HashMap[K, V]) Clear() <span class="cov8" title="1">{
        h.Lock()
        defer h.Unlock()
        h.items = make(map[K]V)
}</span>

// ForEach executes a function for each key-value pair in the map
func (h *HashMap[K, V]) ForEach(fn func(key K, value V)) <span class="cov8" title="1">{
        h.RLock()
        defer h.RUnlock()
        for k, v := range h.items </span><span class="cov8" title="1">{
                fn(k, v)
        }</span>
}

// Values
func (h *HashMap[K, V]) Values() []V <span class="cov0" title="0">{
        h.RLock()
        defer h.RUnlock()
        values := make([]V, 0, len(h.items))
        for _, v := range h.items </span><span class="cov0" title="0">{
                values = append(values, v)
        }</span>
        <span class="cov0" title="0">return values</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package concurrent

import "sync"

type Node[K comparable, V any] struct {
        key        K
        value      V
        prev, next *Node[K, V]
}

type LRU[K comparable, V any] struct {
        capacity int
        cache    map[K]*Node[K, V]
        head     *Node[K, V]
        tail     *Node[K, V]
        mutex    sync.Mutex
}

func NewLRU[K comparable, V any](capacity int) *LRU[K, V] <span class="cov8" title="1">{
        return &amp;LRU[K, V]{
                capacity: capacity,
                cache:    make(map[K]*Node[K, V]),
                head:     nil,
                tail:     nil,
                mutex:    sync.Mutex{},
        }
}</span>

func (l *LRU[K, V]) Get(key K) (V, bool) <span class="cov8" title="1">{
        l.mutex.Lock()
        defer l.mutex.Unlock()

        if node, exists := l.cache[key]; exists </span><span class="cov8" title="1">{
                l.moveToFront(node)
                return node.value, true
        }</span>
        <span class="cov8" title="1">var zero V
        return zero, false</span>
}

func (l *LRU[K, V]) Put(key K, value V) <span class="cov8" title="1">{
        l.mutex.Lock()
        defer l.mutex.Unlock()

        if node, exists := l.cache[key]; exists </span><span class="cov8" title="1">{
                node.value = value
                l.moveToFront(node)
                return
        }</span>

        <span class="cov8" title="1">newNode := &amp;Node[K, V]{key: key, value: value}
        l.cache[key] = newNode

        if len(l.cache) == 1 </span><span class="cov8" title="1">{
                l.head = newNode
                l.tail = newNode
        }</span> else<span class="cov8" title="1"> {
                newNode.next = l.head
                l.head.prev = newNode
                l.head = newNode
        }</span>

        <span class="cov8" title="1">if len(l.cache) &gt; l.capacity </span><span class="cov8" title="1">{
                delete(l.cache, l.tail.key)
                l.tail = l.tail.prev
                l.tail.next = nil
        }</span>
}

func (l *LRU[K, V]) moveToFront(node *Node[K, V]) <span class="cov8" title="1">{
        if node == l.head </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if node == l.tail </span><span class="cov8" title="1">{
                l.tail = node.prev
                l.tail.next = nil
        }</span> else<span class="cov8" title="1"> {
                node.prev.next = node.next
                node.next.prev = node.prev
        }</span>

        <span class="cov8" title="1">node.prev = nil
        node.next = l.head
        l.head.prev = node
        l.head = node</span>
}

func (l *LRU[K, V]) Len() int <span class="cov8" title="1">{
        l.mutex.Lock()
        defer l.mutex.Unlock()
        return len(l.cache)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package concurrent

import (
        "sync"
)

// Set represents a thread-safe set data structure
type Set[T comparable] struct {
        sync.RWMutex
        items map[T]struct{}
}

// NewSet creates a new Set
func NewSet[T comparable]() *Set[T] <span class="cov8" title="1">{
        return &amp;Set[T]{
                items: make(map[T]struct{}),
        }
}</span>

// Add adds an item to the set
func (s *Set[T]) Add(item T) <span class="cov8" title="1">{
        s.Lock()
        defer s.Unlock()
        s.items[item] = struct{}{}
}</span>

// Remove removes an item from the set
func (s *Set[T]) Remove(item T) <span class="cov8" title="1">{
        s.Lock()
        defer s.Unlock()
        delete(s.items, item)
}</span>

// Contains checks if an item exists in the set
func (s *Set[T]) Contains(item T) bool <span class="cov8" title="1">{
        s.RLock()
        defer s.RUnlock()
        _, exists := s.items[item]
        return exists
}</span>

// Size returns the number of items in the set
func (s *Set[T]) Size() int <span class="cov8" title="1">{
        s.RLock()
        defer s.RUnlock()
        return len(s.items)
}</span>

// Clear removes all items from the set
func (s *Set[T]) Clear() <span class="cov8" title="1">{
        s.Lock()
        defer s.Unlock()
        s.items = make(map[T]struct{})
}</span>

// Items returns a slice of all items in the set
func (s *Set[T]) Items() []T <span class="cov8" title="1">{
        s.RLock()
        defer s.RUnlock()
        items := make([]T, 0, len(s.items))
        for item := range s.items </span><span class="cov8" title="1">{
                items = append(items, item)
        }</span>
        <span class="cov8" title="1">return items</span>
}

func (s *Set[T]) ForEach(fn func(item T)) <span class="cov0" title="0">{
        s.RLock()
        defer s.RUnlock()
        for item := range s.items </span><span class="cov0" title="0">{
                fn(item)
        }</span>
}

// Union returns a new set containing all elements from both sets
func (s *Set[T]) Union(other *Set[T]) *Set[T] <span class="cov8" title="1">{
        result := NewSet[T]()
        s.RLock()
        other.RLock()
        defer s.RUnlock()
        defer other.RUnlock()

        for item := range s.items </span><span class="cov8" title="1">{
                result.items[item] = struct{}{}
        }</span>
        <span class="cov8" title="1">for item := range other.items </span><span class="cov8" title="1">{
                result.items[item] = struct{}{}
        }</span>

        <span class="cov8" title="1">return result</span>
}

// Intersection returns a new set containing elements present in both sets
func (s *Set[T]) Intersection(other *Set[T]) *Set[T] <span class="cov8" title="1">{
        result := NewSet[T]()
        s.RLock()
        other.RLock()
        defer s.RUnlock()
        defer other.RUnlock()

        for item := range s.items </span><span class="cov8" title="1">{
                if _, exists := other.items[item]; exists </span><span class="cov8" title="1">{
                        result.items[item] = struct{}{}
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package fanout

import (
        models "gtsdb/models"
        "sync"
)

type Consumer struct {
        ID       int
        Callback func(models.DataPoint)
}

type Fanout struct {
        consumers []*Consumer
        messageCh chan models.DataPoint
        mu        sync.RWMutex
        wg        sync.WaitGroup
}

func NewFanout() *Fanout <span class="cov8" title="1">{
        return &amp;Fanout{
                consumers: make([]*Consumer, 0),
                messageCh: make(chan models.DataPoint),
        }
}</span>

func (f *Fanout) Start() <span class="cov8" title="1">{
        go f.producer()
}</span>

func (f *Fanout) AddConsumer(id int, callback func(models.DataPoint)) <span class="cov8" title="1">{
        f.mu.Lock()
        defer f.mu.Unlock()
        consumer := &amp;Consumer{ID: id, Callback: callback}
        f.consumers = append(f.consumers, consumer)
        f.wg.Add(1)
}</span>

func (f *Fanout) RemoveConsumer(id int) <span class="cov0" title="0">{
        f.mu.Lock()
        defer f.mu.Unlock()
        for i, c := range f.consumers </span><span class="cov0" title="0">{
                if c.ID == id </span><span class="cov0" title="0">{
                        f.consumers = append(f.consumers[:i], f.consumers[i+1:]...)
                        f.wg.Done()
                        break</span>
                }
        }
}

func (f *Fanout) Publish(msg models.DataPoint) <span class="cov8" title="1">{
        f.messageCh &lt;- msg
}</span>

func (f *Fanout) Wait() <span class="cov0" title="0">{
        f.wg.Wait()
}</span>

func (f *Fanout) producer() <span class="cov8" title="1">{
        for msg := range f.messageCh </span><span class="cov8" title="1">{
                f.mu.RLock()
                for _, c := range f.consumers </span><span class="cov8" title="1">{
                        go c.Callback(msg)
                }</span>
                <span class="cov8" title="1">f.mu.RUnlock()</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        "gtsdb/buffer"
        "gtsdb/models"
        "time"
)

type WriteRequest struct {
        ID        string  `json:"id"`
        Value     float64 `json:"value"`
        Timestamp int64   `json:"timestamp,omitempty"`
}

type ReadRequest struct {
        ID          string `json:"id"`
        StartTime   int64  `json:"startTime,omitempty"`
        EndTime     int64  `json:"endTime,omitempty"`
        Downsample  int    `json:"downsample,omitempty"`
        LastX       int    `json:"lastx,omitempty"`
        Aggregation string `json:"aggregation,omitempty"`
}

type Operation struct {
        Operation string        `json:"operation"` // "write", "read", "flush", "subscribe"
        Write     *WriteRequest `json:"write,omitempty"`
        Read      *ReadRequest  `json:"read,omitempty"`
        DeviceID  string        `json:"deviceId,omitempty"`
}

type Response struct {
        Success bool        `json:"success"`
        Message string      `json:"message,omitempty"`
        Data    interface{} `json:"data,omitempty"`
}

func HandleOperation(op Operation) Response <span class="cov8" title="1">{
        switch op.Operation </span>{
        case "write":<span class="cov8" title="1">
                if op.Write == nil </span><span class="cov8" title="1">{
                        return Response{Success: false, Message: "Write data required"}
                }</span>
                <span class="cov8" title="1">if op.Write.Timestamp &lt;= 0 </span><span class="cov8" title="1">{
                        op.Write.Timestamp = time.Now().Unix()
                }</span>
                <span class="cov8" title="1">dataPoint := models.DataPoint{
                        ID:        op.Write.ID,
                        Timestamp: op.Write.Timestamp,
                        Value:     op.Write.Value,
                }
                buffer.StoreDataPointBuffer(dataPoint)
                return Response{Success: true, Message: "Data point stored"}</span>

        case "read":<span class="cov8" title="1">
                if op.Read == nil </span><span class="cov8" title="1">{
                        return Response{Success: false, Message: "Read parameters required"}
                }</span>
                <span class="cov8" title="1">if op.Read.Aggregation == "" </span><span class="cov8" title="1">{
                        op.Read.Aggregation = "avg"
                }</span>

                <span class="cov8" title="1">var response []models.DataPoint
                if op.Read.LastX &gt; 0 || (op.Read.StartTime == 0 &amp;&amp; op.Read.EndTime == 0) </span><span class="cov8" title="1">{
                        last := op.Read.LastX
                        if last == 0 </span><span class="cov0" title="0">{
                                last = 1
                        }</span>
                        <span class="cov8" title="1">if last &lt; 0 </span><span class="cov0" title="0">{
                                last = last * -1
                        }</span>
                        <span class="cov8" title="1">response = buffer.ReadLastDataPoints(op.Read.ID, last)</span>
                } else<span class="cov8" title="1"> {
                        response = buffer.ReadDataPoints(op.Read.ID, op.Read.StartTime, op.Read.EndTime, op.Read.Downsample, op.Read.Aggregation)
                }</span>
                <span class="cov8" title="1">return Response{Success: true, Data: response}</span>

        case "flush":<span class="cov8" title="1">
                buffer.FlushRemainingDataPoints()
                return Response{Success: true, Message: "Data points flushed"}</span>

        default:<span class="cov8" title="1">
                return Response{Success: false, Message: "Invalid operation"}</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handlers

import (
        "encoding/json"
        "fmt"
        "gtsdb/fanout"
        "gtsdb/models"
        "net/http"
        "time"
)

func writeJSON(w http.ResponseWriter, response Response) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)
}</span>

func SetupHTTPRoutes(fanoutManager *fanout.Fanout) http.Handler <span class="cov0" title="0">{
        mux := http.NewServeMux()

        mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                        writeJSON(w, Response{Success: false, Message: "Method not allowed"})
                        return
                }</span>

                <span class="cov0" title="0">var op Operation
                if err := json.NewDecoder(r.Body).Decode(&amp;op); err != nil </span><span class="cov0" title="0">{
                        writeJSON(w, Response{Success: false, Message: "Invalid request body"})
                        return
                }</span>

                <span class="cov0" title="0">if op.Operation == "subscribe" </span><span class="cov0" title="0">{
                        if op.DeviceID == "" </span><span class="cov0" title="0">{
                                writeJSON(w, Response{Success: false, Message: "Device ID required"})
                                return
                        }</span>
                        <span class="cov0" title="0">handleSSE(w, op.DeviceID, fanoutManager)
                        return</span>
                }

                <span class="cov0" title="0">response := HandleOperation(op)
                writeJSON(w, response)</span>
        })

        <span class="cov0" title="0">return mux</span>
}

func handleSSE(w http.ResponseWriter, deviceID string, fanoutManager *fanout.Fanout) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "text/event-stream")
        w.Header().Set("Cache-Control", "no-cache")
        w.Header().Set("Connection", "keep-alive")

        flusher, ok := w.(http.Flusher)
        if !ok </span><span class="cov0" title="0">{
                http.Error(w, "Streaming unsupported", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">id := time.Now().UnixNano()
        fanoutManager.AddConsumer(int(id), func(msg models.DataPoint) </span><span class="cov0" title="0">{
                if msg.ID == deviceID </span><span class="cov0" title="0">{
                        resp := Response{Success: true, Data: msg}
                        jsonData, _ := json.Marshal(resp)
                        fmt.Fprintf(w, "data: %s\n\n", jsonData)
                        flusher.Flush()
                }</span>
        })

        // Wait until connection is closed
        <span class="cov0" title="0">select </span>{}
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package handlers

import (
        "bufio"
        "encoding/json"
        "fmt"
        "gtsdb/fanout"
        "gtsdb/models"

        "math/rand"
        "net"
        "slices"
        "time"
)

func HandleTcpConnection(conn net.Conn, fanoutManager *fanout.Fanout) <span class="cov0" title="0">{
        defer conn.Close()
        id := rand.Intn(1000) + int(time.Now().UnixNano())
        scanner := bufio.NewScanner(conn)
        subscribingDevices := []string{}

        for scanner.Scan() </span><span class="cov0" title="0">{
                var op Operation
                if err := json.Unmarshal(scanner.Bytes(), &amp;op); err != nil </span><span class="cov0" title="0">{
                        response := Response{Success: false, Message: "Invalid JSON format: " + scanner.Text()}
                        json.NewEncoder(conn).Encode(response)
                        continue</span>
                }

                <span class="cov0" title="0">if op.Operation == "subscribe" </span><span class="cov0" title="0">{
                        if op.DeviceID == "" </span><span class="cov0" title="0">{
                                json.NewEncoder(conn).Encode(Response{Success: false, Message: "Device ID required"})
                                continue</span>
                        }
                        <span class="cov0" title="0">subscribingDevices = append(subscribingDevices, op.DeviceID)
                        if len(subscribingDevices) == 1 </span><span class="cov0" title="0">{
                                fmt.Printf("Adding consumer %d %v\n", id, subscribingDevices)
                                fanoutManager.AddConsumer(id, func(msg models.DataPoint) </span><span class="cov0" title="0">{
                                        if slices.Contains(subscribingDevices, msg.ID) </span><span class="cov0" title="0">{
                                                json.NewEncoder(conn).Encode(Response{Success: true, Data: msg})
                                        }</span>
                                })
                        }
                        <span class="cov0" title="0">json.NewEncoder(conn).Encode(Response{Success: true, Message: "Subscribed to " + op.DeviceID})
                        continue</span>
                }

                <span class="cov0" title="0">if op.Operation == "unsubscribe" </span><span class="cov0" title="0">{
                        if op.DeviceID == "" </span><span class="cov0" title="0">{
                                json.NewEncoder(conn).Encode(Response{Success: false, Message: "Device ID required"})
                                continue</span>
                        }
                        <span class="cov0" title="0">for i, device := range subscribingDevices </span><span class="cov0" title="0">{
                                if device == op.DeviceID </span><span class="cov0" title="0">{
                                        subscribingDevices = append(subscribingDevices[:i], subscribingDevices[i+1:]...)
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if len(subscribingDevices) == 0 </span><span class="cov0" title="0">{
                                fmt.Printf("Removing consumer %d\n", id)
                                fanoutManager.RemoveConsumer(id)
                        }</span>
                        <span class="cov0" title="0">json.NewEncoder(conn).Encode(Response{Success: true, Message: "Unsubscribed from " + op.DeviceID})
                        continue</span>
                }

                <span class="cov0" title="0">response := HandleOperation(op)
                json.NewEncoder(conn).Encode(response)</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package main

import (
        "fmt"
        "gtsdb/buffer"
        "gtsdb/fanout"
        "gtsdb/handlers"
        "gtsdb/utils"
        "net"
        "net/http"
        "os"
        "os/signal"
        "time"
)

var fanoutManager = fanout.NewFanout()

const (
        tcpListenAddr  = ":5555"
        httpListenAddr = ":5556"
)

func main() <span class="cov0" title="0">{
        utils.Logln("Ê≠°Ëøé‰ΩøÁî®üêπÂ∞èÂÄâÈº†üêπÊôÇÂ∫èË≥áÊñôÂ∫´ üêÅüêÅ ")
        utils.Logln("üé∂Âê±Âê±üé∂Âê±Âê±üé∂ üêπ")
        utils.Logln("üèÉË∑ëüèÉË∑ëË∑ëË∑ëüèÉ üêπ")
        utils.Log("‰ªäÂ§©ÊòØÔºö%s Âì¶", time.Now().Format("2006-01-02 15:04:05"))

        utils.InitDataDirectory()
        fanoutManager.Start() //this will start 2 go routines in the background

        // Start both TCP and HTTP servers
        go startTCPServer()
        go startHTTPServer()

        // Wait for interrupt signal
        c := make(chan os.Signal, 1)
        signal.Notify(c, os.Interrupt)
        &lt;-c

        utils.Logln("‰∏≠Êñ∑‰ø°Ëôü‰æÜ‰∫ÜÔºÅÂ∞èÂÄâÈº†Ë¶ÅÂÖàÊääÊâÄÊúâÊï∏ÊìöÂ≠òÂ•Ω...Âê±Âê±")
        buffer.FlushRemainingDataPoints()
        utils.Logln("ÂÆâÂÖ®ÊîæÂ•ΩÈ£üÁâ©ÂõûÂÆ∂‰∫ÜÂï¶ÔºÅÊãúÊãúÔºÅ‰∏ãÊ¨°‰æÜÁé©ÂñîÔºÅ")
        os.Exit(0)
}</span>

func startTCPServer() <span class="cov0" title="0">{
        listener, err := net.Listen("tcp", tcpListenAddr)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error listening:", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer listener.Close()

        utils.Logln("üëÇ Áî®ÂøÉÁõ£ËÅΩ TCP " + tcpListenAddr)

        for </span><span class="cov0" title="0">{
                conn, err := listener.Accept()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error accepting connection:", err)
                        continue</span>
                }
                <span class="cov0" title="0">go handlers.HandleTcpConnection(conn, fanoutManager)</span>
        }
}

func startHTTPServer() <span class="cov0" title="0">{
        utils.Log("üëÇ Áî®ÂøÉÁõ£ËÅΩ HTTP " + httpListenAddr)
        http.ListenAndServe(httpListenAddr, handlers.SetupHTTPRoutes(fanoutManager))
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package synchronous

type RingBuffer[T any] struct {
        buffer []T
        size   int
        head   int
        tail   int
}

func NewRingBuffer[T any](capacity int) *RingBuffer[T] <span class="cov8" title="1">{
        return &amp;RingBuffer[T]{
                buffer: make([]T, capacity),
                size:   0,
                head:   0,
                tail:   0,
        }
}</span>

func (rb *RingBuffer[T]) Push(item T) <span class="cov8" title="1">{
        rb.buffer[rb.tail] = item
        rb.tail = (rb.tail + 1) % len(rb.buffer)
        if rb.size &lt; len(rb.buffer) </span><span class="cov8" title="1">{
                rb.size++
        }</span> else<span class="cov8" title="1"> {
                rb.head = (rb.head + 1) % len(rb.buffer)
        }</span>
}

func (rb *RingBuffer[T]) Get(index int) T <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= rb.size </span><span class="cov8" title="1">{
                panic("Index out of bounds")</span>
        }
        <span class="cov8" title="1">pos := (rb.head + index) % len(rb.buffer)
        return rb.buffer[pos]</span>
}

func (rb *RingBuffer[T]) GetAll() []T <span class="cov8" title="1">{
        result := make([]T, rb.size)
        for i := 0; i &lt; rb.size; i++ </span><span class="cov8" title="1">{
                result[i] = rb.Get(i)
        }</span>
        <span class="cov8" title="1">return result</span>
}

func (rb *RingBuffer[T]) Size() int <span class="cov8" title="1">{
        return rb.size
}</span>

func (rb *RingBuffer[T]) Capacity() int <span class="cov0" title="0">{
        return len(rb.buffer)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package utils

import (
        "fmt"
        "os"
        "time"
)

var DataDir = "data"

func dateString() string <span class="cov8" title="1">{
        return time.Now().Format("2006-01-02 15:04:05")
}</span>
func InitDataDirectory() <span class="cov8" title="1">{
        //if dataDir does not exist, create it
        if _, err := os.Stat(DataDir); os.IsNotExist(err) </span><span class="cov8" title="1">{
                err := os.Mkdir(DataDir, 0755)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error creating data directory:", err)
                        os.Exit(1)
                }</span>
        }
}

func Log(message string, args ...interface{}) <span class="cov8" title="1">{
        fmt.Printf("[%s] üêπ %s\n", dateString(), fmt.Sprintf(message, args...))
}</span>

func Error(message string, args ...interface{}) <span class="cov8" title="1">{
        fmt.Printf("[%s] üò° %s\n", dateString(), fmt.Sprintf(message, args...))
}</span>

func Warning(message string, args ...interface{}) <span class="cov8" title="1">{
        fmt.Printf("[%s] üòü %s\n", dateString(), fmt.Sprintf(message, args...))
}</span>

func Debug(message string, args ...interface{}) <span class="cov8" title="1">{
        fmt.Printf("[%s] üîçüêπ %s\n", dateString(), fmt.Sprintf(message, args...))
}</span>

func Logln(messages ...interface{}) <span class="cov0" title="0">{
        fmt.Printf("[%s] üêπ %s\n", dateString(), fmt.Sprint(messages...))
}</span>

func Errorln(messages ...interface{}) <span class="cov0" title="0">{
        fmt.Printf("[%s] üò° %s\n", dateString(), fmt.Sprint(messages...))
}</span>

func Warningln(messages ...interface{}) <span class="cov0" title="0">{
        fmt.Printf("[%s] üòü %s\n", dateString(), fmt.Sprint(messages...))
}</span>

func Debugln(messages ...interface{}) <span class="cov0" title="0">{
        fmt.Printf("[%s] üîçüêπ %s\n", dateString(), fmt.Sprint(messages...))
}</span>

func SetupTestFiles() (string, func()) <span class="cov0" title="0">{
        // Create temporary directory
        tmpDir, err := os.MkdirTemp("", "gtsdb_test")
        if err != nil </span><span class="cov0" title="0">{
                //fatal
                fmt.Println("Error creating temporary directory:", err)
                os.Exit(1)
        }</span>

        // Return cleanup function
        <span class="cov0" title="0">cleanup := func() </span><span class="cov0" title="0">{
                os.RemoveAll(tmpDir)
        }</span>

        <span class="cov0" title="0">return tmpDir, cleanup</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
